<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法练习--栈专题</title>
      <link href="/2025/03/08/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0--%E6%A0%88%E4%B8%93%E9%A2%98/"/>
      <url>/2025/03/08/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0--%E6%A0%88%E4%B8%93%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="删除字符串中的所有相邻重复项"><a href="#删除字符串中的所有相邻重复项" class="headerlink" title="删除字符串中的所有相邻重复项"></a>删除字符串中的所有相邻重复项</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a></p><p>给出由小写字母组成的字符串 <code>s</code>，<strong>重复项删除操作</strong>会选择两个相邻且相同的字母，并删除它们。</p><p>在 <code>s</code> 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p><p><strong>示例：</strong></p><ul><li><strong>输入：</strong>“abbaca”</li><li><strong>输出：</strong>“ca”</li><li><strong>解释：</strong><br>例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”。</li></ul><p><strong>提示：</strong></p><ol><li><code>1 &lt;= s.length &lt;= 105</code></li><li><code>s</code> 仅由小写英文字母组成。</li></ol><p><strong>解题思路</strong></p><p>利用栈去模拟这个字母消消乐的过程，没有必要真的去用数据结构的栈<code>stack</code>，直接使用一个数组模拟即可，在本道题适合用<code>string</code>，因为字母消除完后。栈里剩余的字母就是最终答案。</p><p>遍历字符串并栈模拟的过程：</p><ol><li>如果当前栈不为空：<ul><li>当前字符与栈顶元素相等，弹出栈顶元素。</li><li>当前字符与栈顶元素不相等，将当前字符加入栈。</li></ul></li><li>如果当前栈为空：将当前字符加入栈。</li></ol><p>自己写的超挫代码。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">        st.<span class="built_in">push</span>(s[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> index = <span class="number">1</span>, n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(index &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(st.<span class="built_in">empty</span>()) st.<span class="built_in">push</span>(s[index++]);</span><br><span class="line">            <span class="keyword">if</span>(index == n) <span class="keyword">break</span>; </span><br><span class="line">            <span class="type">char</span> ch = st.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span>(ch == s[index])</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                st.<span class="built_in">push</span>(s[index]);</span><br><span class="line">            </span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string ret;</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> ch = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            ret += ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ret.<span class="built_in">begin</span>(), ret.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>优雅代码。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 函数：移除字符串中的所有相邻重复字符</span></span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string ret;  <span class="comment">// 创建一个空字符串 ret，用于存储处理后的结果</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历字符串 s 中的每个字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ch : s) &#123;</span><br><span class="line">            <span class="comment">// 如果 ret 不为空且当前字符与 ret 最后一个字符相同，删除 ret 最后一个字符</span></span><br><span class="line">            <span class="keyword">if</span>(ret.<span class="built_in">size</span>() &amp;&amp; ch == ret.<span class="built_in">back</span>()) &#123;</span><br><span class="line">                ret.<span class="built_in">pop_back</span>();  <span class="comment">// 移除最后一个字符</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否则，将当前字符添加到 ret 的末尾</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ret += ch;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回处理后的字符串</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ul><li>时间复杂度：$O(n)$，其中 <code>n</code> 是字符串 <code>s</code> 的长度。</li><li>空间复杂度：$O(1)$，返回值的空间不计入。</li></ul><hr><h1 id="比较含退格的字符串"><a href="#比较含退格的字符串" class="headerlink" title="比较含退格的字符串"></a>比较含退格的字符串</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/backspace-string-compare/">比较含退格的字符串</a></p><p>给定 <code>s</code> 和 <code>t</code> 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 <code>true</code> 。<code>#</code> 代表退格字符。</p><p><strong>注意：</strong> 如果对空文本输入退格字符，文本继续为空。</p><p><strong>示例 1：</strong></p><ul><li><strong>输入：</strong> s = “ab#c”, t = “ad#c”</li><li><strong>输出：</strong> true</li><li><strong>解释：</strong> s 和 t 都会变成 “ac”。</li></ul><p><strong>示例 2：</strong></p><ul><li><strong>输入：</strong> s = “ab##”, t = “c#d#”</li><li><strong>输出：</strong> true</li><li><strong>解释：</strong> s 和 t 都会变成 “”。</li></ul><p><strong>示例 3：</strong></p><ul><li><strong>输入：</strong> s = “a#c”, t = “b”</li><li><strong>输出：</strong> false</li><li><strong>解释：</strong> s 会变成 “c”，但 t 仍然是 “b”。</li></ul><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length, t.length &lt;= 200</code></li><li><code>s</code> 和 <code>t</code> 只含有小写字母以及字符 <code>&#39;#&#39;</code></li></ul><p><strong>解法一：栈模拟</strong></p><p>利用栈去模拟字母串退格的过程，遍历字符串，分情况讨论：</p><ol><li>如果当前字符是<code>&#39;#&#39;</code>：<ul><li>栈不为空，弹出栈顶元素。</li><li>栈为空，直接跳过不做处理（退格符<code>&#39;#&#39;</code>可能含有多个，栈不能存储<code>&#39;#&#39;</code>）。</li></ul></li><li>如果当前字符是小写字母：将其加入栈。</li></ol><p>最后我们只需要比较退格处理后得到的两个字符串是否相等即可（不需要真的使用<code>stack</code>，这样还需再做处理，所以用<code>string</code>模拟即可）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 该函数用于处理字符串，模拟退格操作，返回处理后的结果</span></span><br><span class="line">    <span class="function">string <span class="title">GetStr</span><span class="params">(string&amp; str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string ret;</span><br><span class="line">        <span class="comment">// 遍历字符串中的每个字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ch : str)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果字符是 &#x27;#&#x27; 且 ret 非空，弹出栈顶元素（模拟退格键）</span></span><br><span class="line">            <span class="keyword">if</span>(ret.<span class="built_in">size</span>() &amp;&amp; ch == <span class="string">&#x27;#&#x27;</span>) ret.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="comment">// 如果字符是字母，则将其添加到 ret</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isalpha</span>(ch)) ret += ch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;  <span class="comment">// 返回处理后的字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 比较两个字符串经过处理后的结果是否相同</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">backspaceCompare</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">GetStr</span>(s) == <span class="built_in">GetStr</span>(t);  <span class="comment">// 比较两个处理后的字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(m + n)$，<code>m</code>和<code>n</code>分别为两个字符串的长度。</li><li>空间复杂度：$O(m + n)$，用于存储退格处理后的字符串。</li></ul><hr><p><strong>解法二：双指针</strong></p><p>具体可参考这个：<a href="https://leetcode.cn/problems/backspace-string-compare/solutions/683776/shuang-zhi-zhen-bi-jiao-han-tui-ge-de-zi-8fn8/">御三五佬的题解</a></p><p>退格处理消去左边的字符，对右边的字符没有影响，所以我们可以有一个大致的思路：从后遍历字符串，遇到<code>&#39;#&#39;</code>时就用变量记录下有多少个，遇到字母时指针向前移动消去多少个字符。</p><p>接着来看具体的分析，我们可以利用双指针<code>i</code>和<code>j</code>从后遍历字符串同时用两个变量<code>skipS</code>和<code>skipT</code>去记录遍历中两个字符串<code>&#39;#&#39;</code>的数量，首先得对字符串<code>s</code>做退格处理，如果当前字符为<code>&#39;#&#39;</code>，<code>skipS++, i--</code>；如果当前字符为字母且<code>skipS</code>不为空，说明该字符需要被消去，<code>skipS--, i--</code>，由于可能有多个字符需要被消去，故退格处理需要写成循环；如果当前字符为字母且<code>skipS</code>为空，这时候就不需要退格处理，退出循环。对字符串<code>t</code>同样需要做退格处理。</p><p>当两个字符串都经过退格处理后，需要比较<code>i</code>和<code>j</code>位置的字符串是否相等，不相等直接返回<code>false</code>；当一个指针越界后但另外一个没有走完，也需要返回<code>false</code>。比较完之后双指针再同时向前移动，整个大循环结束后说明能够一一匹配，返回<code>true</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">backspaceCompare</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>, j = t.<span class="built_in">size</span>() - <span class="number">1</span>;  <span class="comment">// 初始化指针 i 和 j，分别指向 s 和 t 的末尾</span></span><br><span class="line">        <span class="type">int</span> skipS = <span class="number">0</span>, skipT = <span class="number">0</span>;  <span class="comment">// 用来记录需要跳过的字符数，模拟退格操作</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当 i 或 j 指向的索引还在有效范围内时，继续遍历</span></span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 处理字符串 s</span></span><br><span class="line">            <span class="keyword">while</span>(i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">&#x27;#&#x27;</span>)  <span class="comment">// 如果字符是 &#x27;#&#x27;，则增加跳过字符的计数器</span></span><br><span class="line">                    skipS++, i--;  <span class="comment">// 退格，跳过当前字符</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(skipS &gt; <span class="number">0</span>) &#123;  <span class="comment">// 如果有跳过字符的计数，减少计数器并继续向前扫描</span></span><br><span class="line">                    skipS--;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;  <span class="comment">// 如果没有退格操作，则停下</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理字符串 t</span></span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(t[j] == <span class="string">&#x27;#&#x27;</span>)  <span class="comment">// 如果字符是 &#x27;#&#x27;，则增加跳过字符的计数器</span></span><br><span class="line">                    skipT++, j--;  <span class="comment">// 退格，跳过当前字符</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(skipT &gt; <span class="number">0</span>) &#123;  <span class="comment">// 如果有跳过字符的计数，减少计数器并继续向前扫描</span></span><br><span class="line">                    skipT--;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;  <span class="comment">// 如果没有退格操作，则停下</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 比较当前字符，若都有效并且不相同则返回 false</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] != t[j]) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 如果对应字符不相同，返回 false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果有一个字符串已经遍历完，但另一个字符串还未遍历完，说明不相同</span></span><br><span class="line">                <span class="keyword">if</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 如果其中一个字符串没有完全匹配到末尾，返回 false</span></span><br><span class="line">            &#125;</span><br><span class="line">            i--;  <span class="comment">// 向前移动指针</span></span><br><span class="line">            j--;  <span class="comment">// 向前移动指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 如果所有字符都匹配，返回 true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(m + n)$，<code>m</code>和<code>n</code>分别为两个字符串的长度。</li><li>空间复杂度：$O(1)$</li></ul><hr><h1 id="基本计算器-II"><a href="#基本计算器-II" class="headerlink" title="基本计算器 II"></a>基本计算器 II</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/basic-calculator-ii/">227. 基本计算器 II</a></p><p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p><p>整数除法仅保留整数部分。</p><p>你可以假设给定的表达式总是有效的。所有中间结果将在 <code>[-231, 231 - 1]</code> 的范围内。</p><p><strong>注意：</strong>不允许使用任何将字符串作为数学表达式计算的内置函数，比如 <code>eval()</code> 。</p><p><strong>示例 1：</strong></p><ul><li><strong>输入：</strong> s = “3+2*2”</li><li><strong>输出：</strong> 7</li></ul><p><strong>示例 2：</strong></p><ul><li><strong>输入：</strong> s = “ 3/2 “</li><li><strong>输出：</strong> 1</li></ul><p><strong>示例 3：</strong></p><ul><li><strong>输入：</strong> s = “ 3+5 / 2 “</li><li><strong>输出：</strong> 5</li></ul><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 3 * 105</code></li><li><code>s</code> 由整数和算符 <code>(&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;)</code> 组成，中间由一些空格隔开</li><li><code>s</code> 表示一个 <strong>有效表达式</strong></li><li>表达式中的所有整数都是非负整数，且在范围 <code>[0, 231 - 1]</code> 内</li><li>题目数据保证答案是一个 <strong>32-bit 整数</strong></li></ul><p><strong>解题思路：栈模拟</strong></p><p>用一个数组<code>st</code>去模拟栈，然后遍历字符串：</p><ol><li>遇到空格时，跳过。</li><li>遇到数字时，提取完整的数字（支持多位数字），根据当前运算符对数字进行操作：<ul><li>如果是加号，数字直接加入 <code>st</code>。</li></ul><ul><li>如果是减号，数字作为负数加入 <code>st</code>。</li><li>如果是乘号或除号，则更新 <code>st</code> 中最后一个元素的值（因为乘除是优先级更高的运算）。</li></ul></li><li>遇到运算符时，更新 <code>Operator</code>。</li></ol><p>所有的乘法和除法已经在 <code>st</code> 中通过修改最后一个元素完成了，最后只需要对 <code>retArr</code> 进行求和，得到最终的结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();  <span class="comment">// 获取表达式字符串的长度</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; st;  <span class="comment">// 使用栈来存储中间结果</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;  <span class="comment">// 字符串索引</span></span><br><span class="line">        <span class="type">char</span> Operator = <span class="string">&#x27;+&#x27;</span>;  <span class="comment">// 默认操作符是加法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历整个字符串</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="type">char</span> ch = s[i];  <span class="comment">// 获取当前字符</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 跳过空格</span></span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 如果是数字</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">                <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 构建数字，处理多位数字</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; n &amp;&amp; <span class="built_in">isdigit</span>(s[i])) &#123;</span><br><span class="line">                    num = num * <span class="number">10</span> + (s[i++] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 根据前一个操作符对栈进行处理</span></span><br><span class="line">                <span class="keyword">switch</span> (Operator) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    st.<span class="built_in">push_back</span>(num);  <span class="comment">// 加法直接将数字推入栈</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    st.<span class="built_in">push_back</span>(-num);  <span class="comment">// 减法将负数推入栈</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    st.<span class="built_in">back</span>() *= num;  <span class="comment">// 乘法与栈顶元素相乘</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    st.<span class="built_in">back</span>() /= num;  <span class="comment">// 除法与栈顶元素相除</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 如果是操作符，更新当前操作符</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Operator = s[i++];  <span class="comment">// 更新操作符，并继续遍历下一个字符</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后计算栈中所有数字的总和</span></span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : st) &#123;</span><br><span class="line">            ret += x;  <span class="comment">// 累加栈中的所有元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;  <span class="comment">// 返回最终结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$，$n$ 为字符串 $s$ 长度。</li><li>空间复杂度：$O(n)$，模拟栈的数组 $st$ 的空间开销。</li></ul><hr><h1 id="字符串解码"><a href="#字符串解码" class="headerlink" title="字符串解码"></a>字符串解码</h1><p><strong>题目：</strong><a href="https://leetcode.cn/problems/decode-string/">394. 字符串解码</a></p><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p><p><strong>示例 1：</strong></p><ul><li><strong>输入：</strong> s = “3[a]2[bc]”</li><li><strong>输出：</strong>“aaabcbc”</li></ul><p><strong>示例 2：</strong></p><ul><li><strong>输入：</strong> s = “3[a2[c]]”</li><li><strong>输出：</strong>“accaccacc”</li></ul><p><strong>示例 3：</strong></p><ul><li><strong>输入：</strong> s = “2[abc]3[cd]ef”</li><li><strong>输出：</strong>“abcabccdcdcdef”</li></ul><p><strong>示例 4：</strong></p><p><strong>输入：</strong> s = “abc3[cd]xyz”<br><strong>输出：</strong>“abccdcdcdxyz”</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 30</code></li><li><code>s</code> 由小写英文字母、数字和方括号 <code>&#39;[]&#39;</code> 组成</li><li><code>s</code> 保证是一个 <strong>有效</strong> 的输入。</li><li><code>s</code> 中所有整数的取值范围为 <code>[1, 300]</code></li></ul><p><strong>解题思路：栈模拟</strong></p><p>利用两个栈<code>ret</code>和<code>nums</code>去存储最近的字符串与数字，遍历原始字符串，分情况处理：</p><ol><li>如果当前字符是数字，将数字提取出来，加入<code>nums</code>。</li><li>如果当前字符是<code>&#39;[&#39;</code>，将后面的字符串提取出来，加入<code>ret</code>。</li><li>如果当前字符是<code>&#39;]&#39;</code>，两个栈同时出栈，获取需要重复的次数<code>cnt</code>和字符串<code>str</code>，将<code>str</code>追加到<code>ret</code>的栈顶元素的末尾，重复<code>cnt</code>次。</li><li>如果当前字符是字母，提取当前位置及其往后的字符串，将其加入<code>ret</code>。</li></ol><p>注意：由于步骤3可能会对空栈进行操作，所以将<code>ret</code>初始化带有一个空字符串的栈。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">decodeString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ret 用于存储当前解码过程中构建的字符串。初始化为一个空字符串的 vector。</span></span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">ret</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;&quot;</span>)</span></span>;</span><br><span class="line">        <span class="comment">// nums 用于存储数字，记录需要重复的次数</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, n = s.<span class="built_in">size</span>(); <span class="comment">// 初始化指针 i 和字符串长度 n</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123; <span class="comment">// 遍历字符串的每个字符</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i])) &#123; <span class="comment">// 如果当前字符是数字</span></span><br><span class="line">                <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 处理多位数数字</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">isdigit</span>(s[i]))</span><br><span class="line">                    x = x * <span class="number">10</span> + (s[i++] - <span class="string">&#x27;0&#x27;</span>); <span class="comment">// 构建完整的数字</span></span><br><span class="line">                nums.<span class="built_in">push_back</span>(x); <span class="comment">// 将数字压入 nums 栈中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;[&#x27;</span>) &#123; <span class="comment">// 如果当前字符是 &#x27;[&#x27;，表示开始一个新的编码段</span></span><br><span class="line">                string str;</span><br><span class="line">                i++; <span class="comment">// 跳过 &#x27;[&#x27;</span></span><br><span class="line">                <span class="comment">// 将 &#x27;[&#x27; 后面的字母收集到 str 中</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">isalpha</span>(s[i]))</span><br><span class="line">                    str += s[i++];</span><br><span class="line">                ret.<span class="built_in">push_back</span>(str); <span class="comment">// 将收集到的字符串压入 ret 栈中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;]&#x27;</span>) &#123; <span class="comment">// 如果当前字符是 &#x27;]&#x27;，表示一个编码段结束</span></span><br><span class="line">                <span class="type">int</span> cnt = nums.<span class="built_in">back</span>(); <span class="comment">// 获取需要重复的次数</span></span><br><span class="line">                nums.<span class="built_in">pop_back</span>(); <span class="comment">// 弹出栈中的重复次数</span></span><br><span class="line">                string tmp = ret.<span class="built_in">back</span>(); <span class="comment">// 获取最近的字符串</span></span><br><span class="line">                ret.<span class="built_in">pop_back</span>(); <span class="comment">// 弹出栈中的字符串</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将 tmp 字符串重复 cnt 次，追加到 ret 栈顶的字符串后</span></span><br><span class="line">                <span class="keyword">while</span> (cnt--)</span><br><span class="line">                    ret.<span class="built_in">back</span>() += tmp;</span><br><span class="line">                i++; <span class="comment">// 跳过 &#x27;]&#x27;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果当前字符是字母</span></span><br><span class="line">                string tmp;</span><br><span class="line">                <span class="comment">// 收集字母字符</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; n &amp;&amp; <span class="built_in">isalpha</span>(s[i]))</span><br><span class="line">                    tmp += s[i++];</span><br><span class="line">                ret.<span class="built_in">back</span>() += tmp; <span class="comment">// 将字母追加到 ret 栈顶的字符串后</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret.<span class="built_in">back</span>(); <span class="comment">// 返回最终解码后的字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$，其中 <code>n</code> 是输入字符串的长度。</li><li>空间复杂度：$O(n)$，主要用于存储解码过程中构建的字符串。</li></ul><hr><h1 id="验证栈序列"><a href="#验证栈序列" class="headerlink" title="验证栈序列"></a>验证栈序列</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/validate-stack-sequences/">946. 验证栈序列</a></p><p>给定 <code>pushed</code> 和 <code>popped</code> 两个序列，每个序列中的 <strong>值都不重复</strong>，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 <code>true</code>；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><ul><li><strong>输入：</strong> pushed = [1,2,3,4,5], popped = [4,5,3,2,1]</li><li><strong>输出：</strong> true</li><li><strong>解释：</strong> 我们可以按以下顺序执行：<br>  push(1), push(2), push(3), push(4), pop() -&gt; 4,<br>  push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</li></ul><p><strong>示例 2：</strong></p><ul><li><strong>输入：</strong> pushed = [1,2,3,4,5], popped = [4,3,5,1,2]</li><li><strong>输出：</strong> false</li><li><strong>解释：</strong> 1 不能在 2 之前弹出。</li></ul><p><strong>提示：</strong></p><ul><li><code>1 &lt;= pushed.length &lt;= 1000</code></li><li><code>0 &lt;= pushed[i] &lt;= 1000</code></li><li><code>pushed</code> 的所有元素 <strong>互不相同</strong></li><li><code>popped.length == pushed.length</code></li><li><code>popped</code> 是 <code>pushed</code> 的一个排列</li></ul><p><strong>解题思路：栈模拟</strong></p><p>通过模拟栈的操作，验证最终是否以<code>popped</code> 数组的顺序进行所有出栈操作。遍历<code>pushed</code>数组，将元素一个个压入栈中。每次压入栈后，检查栈顶元素是否与<code>popped[i]</code>相等。如果相等，表示我们可以进行出栈操作，<code>i</code>自增，继续进行下一步操作，直到栈顶元素与<code>popped[i]</code>不相等。</p><p>遍历完<code>pushed</code>数组，检查栈是否为空。如果栈为空，表示出栈操作成功完成了所有元素的匹配，返回<code>true</code>；如果栈不为空，表示有些元素没有按<code>popped</code>的顺序出栈，返回<code>false</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validateStackSequences</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; pushed, vector&lt;<span class="type">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// 定义一个变量 i 来记录当前在 popped 数组中的位置</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st; <span class="comment">// 使用栈来模拟进栈和出栈操作</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历 pushed 数组中的元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : pushed) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(x); <span class="comment">// 将当前元素进栈</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 当栈不为空，并且栈顶元素和 popped 中当前位置的元素相等时</span></span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>() == popped[i]) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>(); <span class="comment">// 出栈</span></span><br><span class="line">                i++; <span class="comment">// 移动到下一个要出栈的元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果栈为空，说明所有的出栈操作都成功匹配了</span></span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$，，其中 <code>n</code> 是数组 <code>pushed</code> 和 <code>popped</code> 的长度。</li><li>空间复杂度：$O(n)$，使用了一个栈来保存最多 <code>n</code> 个元素。</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/03/06/hello-world/"/>
      <url>/2025/03/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> hello </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Second article</title>
      <link href="/2025/03/06/Second/"/>
      <url>/2025/03/06/Second/</url>
      
        <content type="html"><![CDATA[<div class="note modern"><p>默认 提示块标签</p></div><div class="note default modern"><p>default 提示块标签</p></div><div class="note primary modern"><p>primary 提示块标签</p></div><div class="note success modern"><p>success 提示块标签</p></div><div class="note info modern"><p>info 提示块标签</p></div><div class="note warning modern"><p>warning 提示块标签</p></div><div class="note danger modern"><p>danger 提示块标签</p></div>]]></content>
      
      
      <categories>
          
          <category> testCat </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Third article</title>
      <link href="/2025/03/06/Third/"/>
      <url>/2025/03/06/Third/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> testCat </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>first article</title>
      <link href="/2025/03/06/FirstArticle/"/>
      <url>/2025/03/06/FirstArticle/</url>
      
        <content type="html"><![CDATA[<h1 id="My-First-Article"><a href="#My-First-Article" class="headerlink" title="My First Article"></a>My First Article</h1><ul><li>彩色文字<br>在一段话中方便插入各种颜色的标签，包括：<span class='p red'>红色</span>、<span class='p yellow'>黄色</span>、<span class='p green'>绿色</span>、<span class='p cyan'>青色</span>、<span class='p blue'>蓝色</span>、<span class='p gray'>灰色</span>。</li><li>超大号文字<br>文档「开始」页面中的标题部分就是超大号文字。<span class='p center logo large'>Volantis</span><span class='p center small'>A Wonderful Theme for Hexo</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> testCat </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
